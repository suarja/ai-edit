# Usage Tracking Implementation for TestFlight

## Overview

This document outlines the implementation plan for a usage tracking system to limit video generation in the TestFlight version of AI Edit without requiring payment integration. The system will track the number of videos generated by each user and enforce configurable usage limits.

## Database Schema

### `user_usage` Table

```sql
CREATE TABLE user_usage (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  videos_generated INTEGER NOT NULL DEFAULT 0,
  videos_limit INTEGER NOT NULL DEFAULT 5,
  last_reset_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  next_reset_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT (now() + INTERVAL '30 days'),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  CONSTRAINT unique_user_usage UNIQUE (user_id)
);

-- Add RLS policies
ALTER TABLE user_usage ENABLE ROW LEVEL SECURITY;

-- Users can read their own usage
CREATE POLICY "Users can read their own usage"
  ON user_usage
  FOR SELECT
  USING (auth.uid() = user_id);

-- Only server-side functions can update usage
CREATE POLICY "Server can update usage"
  ON user_usage
  FOR UPDATE
  USING (true)
  WITH CHECK (true);

-- Only server-side functions can insert usage
CREATE POLICY "Server can insert usage"
  ON user_usage
  FOR INSERT
  WITH CHECK (true);

-- Function to reset usage monthly
CREATE OR REPLACE FUNCTION reset_monthly_usage()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.next_reset_date <= NOW() THEN
    NEW.videos_generated := 0;
    NEW.last_reset_date := NOW();
    NEW.next_reset_date := NOW() + INTERVAL '30 days';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to check and reset monthly usage
CREATE TRIGGER check_reset_monthly_usage
  BEFORE UPDATE ON user_usage
  FOR EACH ROW
  EXECUTE FUNCTION reset_monthly_usage();

-- Function to initialize usage record for new users
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.user_usage (user_id)
  VALUES (NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create usage record when new user is created
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION handle_new_user();
```

## API Implementation

### Video Generation API Modification

The existing video generation API (`app/api/videos/generate+api.ts`) will be modified to check and update usage before processing video generation requests:

```typescript
// Step 1: Check user usage before video generation
const { data: usage, error: usageError } = await supabase
  .from('user_usage')
  .select('videos_generated, videos_limit, next_reset_date')
  .eq('user_id', user.id)
  .single();

if (usageError) {
  return errorResponse(
    'Failed to check usage limits',
    HttpStatus.INTERNAL_SERVER_ERROR
  );
}

// Step 2: Validate against limits
if (usage.videos_generated >= usage.videos_limit) {
  return errorResponse(
    'Monthly video generation limit reached. Please wait until ' +
      new Date(usage.next_reset_date).toLocaleDateString() +
      ' for your limit to reset.',
    HttpStatus.FORBIDDEN
  );
}

// Step 3: Generate video as normal
// ...existing video generation code...

// Step 4: Increment usage counter
const { error: updateError } = await supabase
  .from('user_usage')
  .update({
    videos_generated: usage.videos_generated + 1,
    updated_at: new Date().toISOString(),
  })
  .eq('user_id', user.id);

if (updateError) {
  console.error('Failed to update usage counter:', updateError);
  // Continue with response even if counter update fails
}
```

### User Usage API

Create a new API endpoint to fetch the user's current usage statistics:

```typescript
// app/api/usage/[id]+api.ts
import { AuthService } from '@/lib/services/auth';
import { supabase } from '@/lib/supabase';
import {
  successResponse,
  errorResponse,
  HttpStatus,
} from '@/lib/utils/api/responses';

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    // Step 1: Authenticate user
    const authHeader = request.headers.get('Authorization');
    const { user, errorResponse: authError } = await AuthService.verifyUser(
      authHeader
    );

    if (authError) {
      return authError;
    }

    // Step 2: Verify requesting user matches requested ID
    if (user.id !== params.id) {
      return errorResponse('Unauthorized access', HttpStatus.FORBIDDEN);
    }

    // Step 3: Fetch usage data
    const { data, error } = await supabase
      .from('user_usage')
      .select('*')
      .eq('user_id', user.id)
      .single();

    if (error) {
      return errorResponse(
        'Failed to fetch usage data',
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }

    // Step 4: Return usage data
    return successResponse({
      videosGenerated: data.videos_generated,
      videosLimit: data.videos_limit,
      usagePercentage: Math.round(
        (data.videos_generated / data.videos_limit) * 100
      ),
      nextResetDate: data.next_reset_date,
    });
  } catch (error: any) {
    console.error('Error fetching usage data:', error);
    return errorResponse(
      error.message || 'Failed to fetch usage data',
      HttpStatus.INTERNAL_SERVER_ERROR
    );
  }
}
```

## UI Implementation

### Usage Dashboard Component

Create a component to display the user's current usage statistics:

```tsx
// components/UsageDashboard.tsx
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ActivityIndicator } from 'react-native';
import { supabase } from '@/lib/supabase';
import { useAuth } from '@/hooks/useAuth';

type UsageData = {
  videosGenerated: number;
  videosLimit: number;
  usagePercentage: number;
  nextResetDate: string;
};

export default function UsageDashboard() {
  const { user } = useAuth();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [usage, setUsage] = useState<UsageData | null>(null);

  useEffect(() => {
    async function fetchUsage() {
      try {
        setLoading(true);
        const { data, error } = await supabase
          .from('user_usage')
          .select('*')
          .eq('user_id', user?.id)
          .single();

        if (error) throw error;

        setUsage({
          videosGenerated: data.videos_generated,
          videosLimit: data.videos_limit,
          usagePercentage: Math.round(
            (data.videos_generated / data.videos_limit) * 100
          ),
          nextResetDate: new Date(data.next_reset_date).toLocaleDateString(),
        });
      } catch (err: any) {
        console.error('Error fetching usage:', err);
        setError(err.message || 'Failed to load usage data');
      } finally {
        setLoading(false);
      }
    }

    if (user) {
      fetchUsage();
    }
  }, [user]);

  if (loading) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#007AFF" />
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.container}>
        <Text style={styles.errorText}>{error}</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Video Generation Usage</Text>

      <View style={styles.statsContainer}>
        <Text style={styles.statsText}>
          {usage?.videosGenerated} / {usage?.videosLimit} videos used
        </Text>

        <View style={styles.progressBarContainer}>
          <View
            style={[
              styles.progressBar,
              { width: `${usage?.usagePercentage || 0}%` },
              usage?.usagePercentage || 0 > 80 ? styles.warningProgress : {},
            ]}
          />
        </View>

        <Text style={styles.resetText}>Next reset: {usage?.nextResetDate}</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 16,
    backgroundColor: '#1A1A1A',
    borderRadius: 12,
    marginVertical: 8,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 12,
  },
  statsContainer: {
    marginTop: 8,
  },
  statsText: {
    fontSize: 16,
    color: '#FFFFFF',
    marginBottom: 8,
  },
  progressBarContainer: {
    height: 8,
    backgroundColor: '#333333',
    borderRadius: 4,
    overflow: 'hidden',
    marginBottom: 8,
  },
  progressBar: {
    height: '100%',
    backgroundColor: '#007AFF',
    borderRadius: 4,
  },
  warningProgress: {
    backgroundColor: '#FF9500',
  },
  resetText: {
    fontSize: 14,
    color: '#999999',
    marginTop: 4,
  },
  errorText: {
    color: '#FF3B30',
    fontSize: 16,
  },
});
```

### Integration into App

Add the usage dashboard to the user profile or settings screen:

```tsx
// app/(tabs)/profile.tsx
// ...existing imports...
import UsageDashboard from '@/components/UsageDashboard';

export default function ProfileScreen() {
  // ...existing code...

  return (
    <SafeAreaView style={styles.container}>
      <Text style={styles.title}>Profile</Text>

      {/* Usage Dashboard */}
      <UsageDashboard />

      {/* Existing profile content */}
      {/* ... */}
    </SafeAreaView>
  );
}
```

## Admin Capabilities

For TestFlight administrators, create a simple admin interface to adjust user limits:

```tsx
// components/AdminUsageControl.tsx (only visible to admin users)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet, Alert } from 'react-native';
import { supabase } from '@/lib/supabase';

type AdminUsageControlProps = {
  userId: string;
  currentLimit: number;
};

export default function AdminUsageControl({
  userId,
  currentLimit,
}: AdminUsageControlProps) {
  const [newLimit, setNewLimit] = useState(currentLimit.toString());
  const [loading, setLoading] = useState(false);

  const updateLimit = async () => {
    try {
      setLoading(true);
      const limitValue = parseInt(newLimit, 10);

      if (isNaN(limitValue) || limitValue < 1) {
        Alert.alert(
          'Invalid limit',
          'Please enter a valid number greater than 0'
        );
        return;
      }

      const { error } = await supabase
        .from('user_usage')
        .update({ videos_limit: limitValue })
        .eq('user_id', userId);

      if (error) throw error;

      Alert.alert('Success', `User limit updated to ${limitValue} videos`);
    } catch (err: any) {
      console.error('Error updating limit:', err);
      Alert.alert('Error', err.message || 'Failed to update limit');
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Admin: Update User Limit</Text>

      <View style={styles.inputContainer}>
        <Text style={styles.label}>User ID:</Text>
        <Text style={styles.userId}>{userId}</Text>
      </View>

      <View style={styles.inputContainer}>
        <Text style={styles.label}>Current Limit:</Text>
        <Text style={styles.currentLimit}>{currentLimit}</Text>
      </View>

      <View style={styles.inputContainer}>
        <Text style={styles.label}>New Limit:</Text>
        <TextInput
          style={styles.input}
          value={newLimit}
          onChangeText={setNewLimit}
          keyboardType="number-pad"
          returnKeyType="done"
        />
      </View>

      <Button
        title={loading ? 'Updating...' : 'Update Limit'}
        onPress={updateLimit}
        disabled={loading}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 16,
    backgroundColor: '#1A1A1A',
    borderRadius: 12,
    marginVertical: 8,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 16,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  label: {
    fontSize: 16,
    color: '#FFFFFF',
    width: 120,
  },
  userId: {
    fontSize: 14,
    color: '#999999',
    flex: 1,
  },
  currentLimit: {
    fontSize: 16,
    color: '#FFFFFF',
  },
  input: {
    flex: 1,
    height: 40,
    backgroundColor: '#333333',
    borderRadius: 8,
    paddingHorizontal: 12,
    color: '#FFFFFF',
  },
});
```

## Testing Plan

1. **Unit Tests**:

   - Test database triggers for user creation and usage reset
   - Test API endpoints for proper validation and error handling
   - Test UI components for correct rendering of usage data

2. **Integration Tests**:

   - Verify usage counter increments properly with video generation
   - Test limit enforcement when maximum is reached
   - Verify reset date logic works correctly

3. **End-to-End Tests**:
   - Complete flow from user signup to reaching usage limit
   - Admin control functionality
   - Edge cases for users with existing records

## Deployment Steps

1. Apply database migrations to create the `user_usage` table
2. Deploy updated API endpoints for usage checking and tracking
3. Add UI components to display usage information
4. Test the complete flow before TestFlight submission
5. Include usage limits in TestFlight invitation notes
